# 标记语言翻译

XML已经被parse出来了，包括id和静态参数。现在，假设我们不考虑翻译静态参数。

我们需要一组C语言的API用于和GUI内核交互，然后将XML表示的组件层次关系翻译为两部分：一是组件树的创建，二是轮询、调用Lustre后端与更新前端。

组件树的创建按照自底向上的方式进行，这一过程中，给每一个组件分配一个gui内核内的id，之后会通过id来访问组件。id在编译期分配，在创建gui时，把id传入。

轮询需要得知事件的类型和组件id。轮询方式就是，每一次循环，对每一个组件，询问其所有可能的事件是否发生（当然，组件的查询接口是统一的，要传入id指示是哪一个组件），把返回值存在栈变量。有一些事件是用不到的，但是为了简便可以都轮询一次。

在编译期知道事件和节点输入的对应关系，所以下一步就是生成调用Lustre逻辑的代码。将相关的临时变量传至主节点的输入结构体中，调用节点。

在编译期也知道组件参数和节点输出的对应关系，所以下一步是更新gui。调用组件更新的接口，传入组件id和新的值（从主节点输出结构体中取）。更新完后开始下一轮循环。

## 步骤一，静态分析

首先，需要检查widget是否有重复的参数或事件（**注：事件和参数是分开处理的，而且c api不一样，所以有相同名字的事件和参数没问题**），检查xml里出现的widget是否存在，这一步是静态分析。后面有时间也要加上静态参数类型的判断

还需要对子控件的个数一致做出判断，这里，如果没有实现静态参数，就从所有实例推断。

## 步骤二，代码生成

分成上述的几个环节一个一个来就行了

### API:

创建widget：
void create_xxx(int id, int... subids);
xxx:组件名

通知客户端收取事件:
void notify_get_event():

询问事件情况：
T get_xxx_yyy(int id);
xxx:组件名 yyy:事件名 T：事件返回值类型

更新组件参数：
void update_xxx_yyy(int id, T val);
xxx：组件名 yyy：参数名 T：参数类型

通知客户端更新所有改变：（将所有客户端状态push到服务端）
void notify_update_change();

这些api就够了。

### 需要保存的值

主函数需要主节点输入结构体和输出结构体为参数。由用户保证已经分配空间且调用初始化函数。

一系列存放事件发生情况的临时变量。

### 初始化函数

起名为create_gui();
依次调用函数即可。

### 主循环函数
main_loop(In* in, Out* out) {
    while (1) {
        notify_get_event();
        // 轮询。。。
        int tmp1 = get_xxx_yyy(1)
        ...
        ....
        in->ctrl_acg_in1 = tmp1;
        ...
        ...
        main_node(in, out);
        update_xxx_yyy(1, out->ctrl_acg_out_1);...
        .....
        notify_update_change();
    }
}