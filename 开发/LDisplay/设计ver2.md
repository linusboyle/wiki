# 设计ver2

返回去看了看上学期的需求文档，以及结合这段时间和老师的谈话，感觉现在的开发方向不是很正确。当然，第一版比起最开始的ldisplay是要靠谱一些的。

目前，版本1的主要的问题在于和l2c的结合过于紧密。display语言基本上是lustre\*的超集，不仅有和gui相关的特性，也将大部分后端特性糅合在了里面。而从[Scade Display](Scade%20Display.md)的实践看来，Display工具应该是可以单独工作的，唯其如此，才能使工具能和多个后端相配合。

Scade Display是图形化工具，至于内部是否有形式化语言我并不清楚，但我的项目无疑是需要自己设计一种类Lustre语言（姑且称为LDisplay）来解决GUI的问题。按照建议，应该采用MVC架构。

## 架构

其中模型语言是类Lustre语言，包括以下功能：

1. 在预置组件的基础上定义新的组件。
2. 在GUI内实现变换（动画效果等）
3. 定义全局变量（被后端模型控制）

其中，定义新组件的部分需要至少支持多时钟和时态算子，但是不是所有Lustre特性都是前端必需的。

XML是标记语言。和第一版的设计不同，GUI的逻辑层级不在XML而是在LDisplay里定义。XML只负责确定组件的参数，包括组件的物理层次。参照Scade的做法，可以将画布分为数个Layer。每个组件实例只需要两部分参数，一部分是固定的：(x，y)坐标以及Layer号；一部分是组件定义中需要的参数（可选参数我暂时不想实现）。这样就可以完全确定GUI的显示了。

最后，MVC中的C也许并不是必需的。图形规范和后端模型的对接，可以在Lustre编译器，也可以在LDisplay中完成。在LDisplay中完成的话，因为编译器翻译后的C表示不同，就必须为每一个Lustre编译器生成特定的控制代码。不过这部份其实和研究关系不大，只需要能正常工作就行了。

## 模型语言

所以，工作的重点就是LDisplay的重新设计。首先，它应该和Lustre使用相同的类型系统，并兼容大部分版本的Lustre编译器。它需要调用外部（尤其，C语言编写的）组件的能力——因为不像Scade有预置库，必需如此才能有基础组件可用。再者，它需要支持一部分Lustre特性，用以真正地构建有实际意义的新组件；这些特性包括：

1. 变量、等式、分支等基础结构
2. 时态算子，为简便可只用fby和pre
3. 时钟算子，when和merge
4. （？）多时钟节点

## 标记语言与变量

此外，标记语言还需要声明全局可变量（全局变量都是**入**或者**出**的），以及节点引用入变量的能力。在实例化时，可以提供全局入可变量或常量给对应的参数（同样的，不考虑可选参数的问题）。虽然普通的容器和节点没有必要访问全局量，但这对于变换容器是必需的，而我并不希望弄出两种节点来，因此统一给予节点接受全局量的能力。

至于**出**的变量，也就是GUI信号，在标记语言中应该有单独的结构来将节点的返回值绑定到出变量上。这部份可以以后再设计，但是我们知道它完全不影响最主要的模型语言的功能。

## 翻译

因为可能要对接不同的编译器，可以设计一个类似C的底层IM，最后再生成C代码。代码生成的关键在于使用和目标编译器一致的类型系统翻译；至于GUI内部的逻辑是否兼容其实是无所谓的，这部份也可以自己看着发挥。类型系统的部分，可以直接从L2C或者Velus里拿源码，但可能要改的地方就比较多了。

标记语言的翻译相对简单一些，不用考虑GUI层次，只需要机械地实例化组件，并声明好全局变量即可。至于控制器，如果要实现，则需要生成外部全局变量的声明和主循环。