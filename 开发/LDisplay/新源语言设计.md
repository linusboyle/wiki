# 新源语言设计

目前的想法是使用元变量联系显示控件的事件、参数和Lustre变量。这种办法比较灵活，翻译也比较简单（把元变量变成toplevel节点的参数和返回值，然后交给Lustre编译器即可）。元变量的名字通过在XML里绑定id（类似HTML的id）实现。

现在需要考虑几个问题：
1. 目前的设计中，widget节点提供的信息是否足以让显示核心实例化控件？是否需要某种「静态参数」或「编译期参数」？
2. 事件还是基于同步模型吗？能否实现同步->异步的转换？
3. control节点只允许有一个的限制能不能放开？此种机制能不能推广？
4. 组件的时钟怎么理解？

## 静态参数

静态参数可以考虑，但是参数从哪里传入呢？xml里只有字符串，不利于类型系统。
当然，在xml实例化的时候，编译器已经知道静态参数的类型，可以强制类型转换。（yes)

## 事件

关于事件，有几种模型：
1. 完全同步模型，编译器很好做，但是gui套件难找，估计要自己写（而且是用多线程模拟的同步式gui）注：总觉得有偷懒的嫌疑。
2. 依然是同步模型，但是采用服务器-客户端架构。事件异步发生，先存在服务器端，客户端根据自己的时钟去query事件的情况，一个时钟周期就处理一个事件（串变并）。没有事件就自更新。一个问题在于服务器是否能存下大量的事件，客户端的处理速度（时钟周期）能不能达到要求。还有一个问题是在处理一个事件后如果改变组件的状态，后面积累的事件还有没有效？X11是这种模式，但不清楚如果按照X11来写是否会造成应用的不方便。
3. 异步模型，用Node做回调。这种情况下，对于node的原型有很多限制（根据widget的接口），而且要拓展widget节点的信息。在这种情况下，同步语言的很多工具在异步模型下就失去了作用。

首先，gui本质上就是异步的，我想也不可能存在一种“同步式gui套件”。只要gui是由事件驱动，就必然是异步的。理论层面上，之前那篇论文设计的DSL基于同步模型进行gui开发，其使用的确是同步的，但不清楚这种DSL的底层实现，想必也是异步转同步的（实际上，上述论文是研究gui同步模型的语义，所以这个问题并不重要）。在LDisplay进展到形式语义分析之前，都不需要考虑这些问题。同时，完全异步的模型绝对是不可取的。不管是从直觉上，还是从实现难度上，都可见其不可靠。

LDisplay应该基于CS架构的异步转同步进行。不妨假设服务器的能力是无限的，而同步假设也是成立的，所以事件可以被及时地处理。编译器只关注其functional behaviour，不关心time behaviour（至少现在不关心）。发生事件时，和没有事件发生时的逻辑如何区分，放在Lustre部分做（并不困难）。

### 事件冲突

是否支持一个时钟内处理多个事件呢？从直观上来讲，如果一个时钟只处理一个事件，那么如果该同步周期传递给gui内核参数使得此事件后的事件完全失效的话（比如，一个按钮已经被置为不可见了），就会产生一些错误。

不过，即使支持一个时钟内处理多个事件，也不能完全解决这个问题。因为获取的都是上一个周期内产生的事件，在这个周期开始的时候，gui已经被上一个周期更新完毕，这些得到的事件完全有可能已经失效了。

假定gui内核可以在产生事件之后，通过gui的能力自动阻止进一步产生相关的事件（比如在点击一个按钮之后，把按钮disable掉）。同时，在gui被更新后删掉已经没用的事件，那么可能可以实行这种方案。

当然，lustre可以记录上一个周期输出的gui参数，所以就算完全不对gui内核的能力做出假设，也可以将避免冲突的使命交给lustre程序员。lustre程序员只需要参照gui参数上一个周期的值，就可以判断一个事件是不是真的有效（比如，如果上个周期把一个按钮disable了，那么一个click事件就是「假 」的）

结论：不需要关心冲突的问题，至于一个周期内处理的事件数目，按照王老师的想法，每个窗口期都要对每个事件轮询且只轮询一次，也就是说是可以同时处理多个事件的。如果同一类事件在一个周期内发生了，那应该会遵循先后顺序。不妨先按照可以处理多个事件设计，就算最后变成了单事件，也可以用这个框架。

更新：关于多事件还是单事件的问题，现在采用的是多事件的框架，对每个事件轮询一次。加上了通知gui客户端更新和改变的api，至于是更新一个事件，还是多个事件那就是gui客户端的实现了。

## 时钟

现在，在widget声明的部分可以像普通节点一样声明某一个参数或者事件以其他变量为时钟。时钟的存在性检查是在LustreW生成过程进行的（*奇怪的是，L2C不检查时钟是否存在，毕竟从理论上来讲，声明部分的时钟只有可能是声明中的其他变量*）。检查过程只会考虑同一类变量（参数或事件）。

关于依赖时钟有很多复杂的地方，暂时不用管。关于它的特性，需要和王老师再5确认一下。

还有另外一种时钟，是调用方传入的参数的时钟决定的实例的时钟。这是由调用方控制的对节点的调用。不过，组件实际上是虚拟的节点，所以调用方没办法控制。在时钟成立的周期，才会去询问事件是否发生，并更新gui参数。关键是