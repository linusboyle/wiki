# Lab6

> 注：代码量的膨胀导致了一个莫名奇妙的bug（同样存在于标准答案），即缺页异常在内核初始化的早期无法被触发，为此我将早期虚拟存储的相关检查关掉了(check_pgfault)。但是在之后的运行过程中，缺页异常是正常工作的。初步的怀疑是内核大小过大，超过了bootstrap页表的范围。还需进一步调试。

## E1

大部分逻辑没变，将原来的硬编码在schedule函数里的fifo换成了通用性的sched_class，类似于之前的pmm_manager和swap_manager。

ucore运行在单核，因此RR调度算法只维护一个待调度进程的队列。当因为各种原因需要执行调度时，首先取队列头，将之从队列中删除。只要不是idle线程，就将其设为当前进程。如果找不到这样的进程，那就进入idle线程。同时会将原进程插入队尾。

除这些操作外，sched_class里还有proc_tick方法，用于响应时钟中断。它负责每个时间片递减当前进程的slices数，当到达0时就会将进程的need_schedule置位。

### 多级反馈队列调度算法

- 更改run_queue，加入更多的队列，以及各个队列的时间片长度（和run_list同）
- 更改init函数，初始化新的对象
- 更改proc结构体，加入指向队列的指针
- 更改enqueue函数，将新的进程加入到下一级队列（如果是新进程就加入最高级队列）
- 更改pick_next函数，从高到低依次从队列找进程
- proc_tick和schedule函数基本不需要变化

## E2

实现stride还是比较简单的，基本框架和RR算法其实差不多。改动的地方一是使用最小堆管理进程，二是要按照优先级增加stride值。

这里踩了个坑:  
在trap.c里，时钟中断的处理例程需要改动，将lab1~lab5一直使用的print_time()换成schedule class提供的接口。如果不换，ticks会一直在100以内，导致priority.c永远不会结束。