# Lab7

> 对于check_pgfault的修改同上一次。要启用测试，可以删去vmm.c:356的注释。

## E1

信号量是对临界区资源的一种抽象表示，通过定义的两种原语up和down，可以实现同步互斥。

信号量的ucore实现，包括一个计数器和一个等待队列。计数器表示资源的可用量。当使用down原语时，如果可用量至少为1，那么就将计数器减一并返回；如果为0，表示资源不可用，进程将进入等待队列。 up原语将计数器加一，如果此时等待队列不为空，就选择一个等待的进程唤醒之；否则，直接返回。

这种操作类似于互斥锁，但因为信号量的状态不只是两种，所以比较灵活。

### 用户态信号量

用户态需要一种类似的信号量。用户态和内核态的互斥实现的差异在于，用户态不应该被允许获取信号量的等待队列，否则会破坏隔离机制。

一种方法是通过系统调用进行，用一个信号量handle表示一个内核信号量（只保存一个ID），通过init,up,down三种syscall操作。OS负责进行具体的操作。

也可以避免引入太多的系统调用。可以用sleep系统调用+周期性轮询进行用户态的信号量模拟。和忙等待不一样，条件检测只在固定时间点执行，所以性能影响应该不是很大。

## E2

利用信号量进行管程的实现比较简单。总体上，一个管程就是一组条件变量，一个等待队列与一个保证互斥的信号量。所有要操作管程内条件的进程必须串行进入临界区。而条件变量实际就是一个信号量和相应的计数。

wait原语将等待某个条件变量。进程将等待相应条件变量的信号，并睡在其信号量上。多个进程可以等待一个条件变量，但是因为信号不会保持，信号量的值一定不超过1。进入等待前，将会唤起管程中等待的进程。

signal原语发送一个信号。这是一个瞬间信号，不会保持。因为管程的互斥操作，在signal唤起某个进程时，当前进程会进入管程的等待队列。

### 用户态管程

同样的，需要阻止用户态访问管程内部数据结构。由于在内核的实现中，只用到了信号量一种复杂结构。因此如果在上一节实现了用户态信号量，那么管程就只是用户态的一种可实现特性。另外，也可以在语言层面提供管程支持。

### 不使用信号量

当然可以不使用信号量来实现管程。只需要把用到信号量的地方换成显式的等待队列操作就行了。可以证明，条件变量里的信号量的值要么是0，要么是1。而且1只会在瞬态出现，所以没必要使用信号量提供的全部功能。一个等待队列足以完成相关的操作（此时，signal原语将队列首唤醒，如果队列是空，就什么也不做）。

而管程用来保持互斥的那个信号量，也可以类似地换成等待队列。